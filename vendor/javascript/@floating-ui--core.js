// @floating-ui/core@1.7.1 downloaded from https://ga.jspm.io/npm:@floating-ui/core@1.7.1/dist/floating-ui.core.mjs

import{getSideAxis as t,getAlignmentAxis as e,getAxisLength as n,getSide as o,getAlignment as s,evaluate as i,getPaddingObject as c,rectToClientRect as r,min as l,clamp as a,getOppositeAlignmentPlacement as f,placements as m,getAlignmentSides as u,getOppositePlacement as d,getExpandedPlacements as g,getOppositeAxisPlacements as p,sides as h,max as y,getOppositeAxis as w}from"@floating-ui/utils";export{rectToClientRect}from"@floating-ui/utils";function x(i,c,r){let{reference:l,floating:a}=i;const f=t(c);const m=e(c);const u=n(m);const d=o(c);const g=f==="y";const p=l.x+l.width/2-a.width/2;const h=l.y+l.height/2-a.height/2;const y=l[u]/2-a[u]/2;let w;switch(d){case"top":w={x:p,y:l.y-a.height};break;case"bottom":w={x:p,y:l.y+l.height};break;case"right":w={x:l.x+l.width,y:h};break;case"left":w={x:l.x-a.width,y:h};break;default:w={x:l.x,y:l.y}}switch(s(c)){case"start":w[m]-=y*(r&&g?-1:1);break;case"end":w[m]+=y*(r&&g?-1:1);break}return w}const v=async(t,e,n)=>{const{placement:o="bottom",strategy:s="absolute",middleware:i=[],platform:c}=n;const r=i.filter(Boolean);const l=await(c.isRTL==null?void 0:c.isRTL(e));let a=await c.getElementRects({reference:t,floating:e,strategy:s});let{x:f,y:m}=x(a,o,l);let u=o;let d={};let g=0;for(let n=0;n<r.length;n++){const{name:i,fn:p}=r[n];const{x:h,y:y,data:w,reset:v}=await p({x:f,y:m,initialPlacement:o,placement:u,strategy:s,middlewareData:d,rects:a,platform:c,elements:{reference:t,floating:e}});f=h!=null?h:f;m=y!=null?y:m;d={...d,[i]:{...d[i],...w}};if(v&&g<=50){g++;if(typeof v==="object"){v.placement&&(u=v.placement);v.rects&&(a=v.rects===true?await c.getElementRects({reference:t,floating:e,strategy:s}):v.rects);({x:f,y:m}=x(a,u,l))}n=-1}}return{x:f,y:m,placement:u,strategy:s,middlewareData:d}};async function b(t,e){var n;e===void 0&&(e={});const{x:o,y:s,platform:l,rects:a,elements:f,strategy:m}=t;const{boundary:u="clippingAncestors",rootBoundary:d="viewport",elementContext:g="floating",altBoundary:p=false,padding:h=0}=i(e,t);const y=c(h);const w=g==="floating"?"reference":"floating";const x=f[p?w:g];const v=r(await l.getClippingRect({element:(n=await(l.isElement==null?void 0:l.isElement(x)))==null||n?x:x.contextElement||await(l.getDocumentElement==null?void 0:l.getDocumentElement(f.floating)),boundary:u,rootBoundary:d,strategy:m}));const b=g==="floating"?{x:o,y:s,width:a.floating.width,height:a.floating.height}:a.reference;const A=await(l.getOffsetParent==null?void 0:l.getOffsetParent(f.floating));const R=await(l.isElement==null?void 0:l.isElement(A))&&await(l.getScale==null?void 0:l.getScale(A))||{x:1,y:1};const D=r(l.convertOffsetParentRelativeRectToViewportRelativeRect?await l.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:b,offsetParent:A,strategy:m}):b);return{top:(v.top-D.top+y.top)/R.y,bottom:(D.bottom-v.bottom+y.bottom)/R.y,left:(v.left-D.left+y.left)/R.x,right:(D.right-v.right+y.right)/R.x}}const A=t=>({name:"arrow",options:t,async fn(o){const{x:r,y:f,placement:m,rects:u,platform:d,elements:g,middlewareData:p}=o;const{element:h,padding:y=0}=i(t,o)||{};if(h==null)return{};const w=c(y);const x={x:r,y:f};const v=e(m);const b=n(v);const A=await d.getDimensions(h);const R=v==="y";const D=R?"top":"left";const P=R?"bottom":"right";const T=R?"clientHeight":"clientWidth";const E=u.reference[b]+u.reference[v]-x[v]-u.floating[b];const O=x[v]-u.reference[v];const k=await(d.getOffsetParent==null?void 0:d.getOffsetParent(h));let L=k?k[T]:0;L&&await(d.isElement==null?void 0:d.isElement(k))||(L=g.floating[T]||u.floating[b]);const C=E/2-O/2;const B=L/2-A[b]/2-1;const H=l(w[D],B);const S=l(w[P],B);const F=H;const V=L-A[b]-S;const W=L/2-A[b]/2+C;const j=a(F,W,V);const z=!p.arrow&&s(m)!=null&&W!==j&&u.reference[b]/2-(W<F?H:S)-A[b]/2<0;const q=z?W<F?W-F:W-V:0;return{[v]:x[v]+q,data:{[v]:j,centerOffset:W-j-q,...z&&{alignmentOffset:q}},reset:z}}});function R(t,e,n){const i=t?[...n.filter((e=>s(e)===t)),...n.filter((e=>s(e)!==t))]:n.filter((t=>o(t)===t));return i.filter((n=>!t||(s(n)===t||!!e&&f(n)!==n)))}const D=function(t){t===void 0&&(t={});return{name:"autoPlacement",options:t,async fn(e){var n,c,r;const{rects:l,middlewareData:a,placement:f,platform:d,elements:g}=e;const{crossAxis:p=false,alignment:h,allowedPlacements:y=m,autoAlignment:w=true,...x}=i(t,e);const v=h!==void 0||y===m?R(h||null,w,y):y;const A=await b(e,x);const D=((n=a.autoPlacement)==null?void 0:n.index)||0;const P=v[D];if(P==null)return{};const T=u(P,l,await(d.isRTL==null?void 0:d.isRTL(g.floating)));if(f!==P)return{reset:{placement:v[0]}};const E=[A[o(P)],A[T[0]],A[T[1]]];const O=[...((c=a.autoPlacement)==null?void 0:c.overflows)||[],{placement:P,overflows:E}];const k=v[D+1];if(k)return{data:{index:D+1,overflows:O},reset:{placement:k}};const L=O.map((t=>{const e=s(t.placement);return[t.placement,e&&p?t.overflows.slice(0,2).reduce(((t,e)=>t+e),0):t.overflows[0],t.overflows]})).sort(((t,e)=>t[1]-e[1]));const C=L.filter((t=>t[2].slice(0,s(t[0])?2:3).every((t=>t<=0))));const B=((r=C[0])==null?void 0:r[0])||L[0][0];return B!==f?{data:{index:D+1,overflows:O},reset:{placement:B}}:{}}}};const P=function(e){e===void 0&&(e={});return{name:"flip",options:e,async fn(n){var s,c;const{placement:r,middlewareData:l,rects:a,initialPlacement:f,platform:m,elements:h}=n;const{mainAxis:y=true,crossAxis:w=true,fallbackPlacements:x,fallbackStrategy:v="bestFit",fallbackAxisSideDirection:A="none",flipAlignment:R=true,...D}=i(e,n);if((s=l.arrow)!=null&&s.alignmentOffset)return{};const P=o(r);const T=t(f);const E=o(f)===f;const O=await(m.isRTL==null?void 0:m.isRTL(h.floating));const k=x||(E||!R?[d(f)]:g(f));const L=A!=="none";!x&&L&&k.push(...p(f,R,A,O));const C=[f,...k];const B=await b(n,D);const H=[];let S=((c=l.flip)==null?void 0:c.overflows)||[];y&&H.push(B[P]);if(w){const t=u(r,a,O);H.push(B[t[0]],B[t[1]])}S=[...S,{placement:r,overflows:H}];if(!H.every((t=>t<=0))){var F,V;const e=(((F=l.flip)==null?void 0:F.index)||0)+1;const n=C[e];if(n){const o=w==="alignment"&&T!==t(n);if(!o||S.every((e=>e.overflows[0]>0&&t(e.placement)===T)))return{data:{index:e,overflows:S},reset:{placement:n}}}let o=(V=S.filter((t=>t.overflows[0]<=0)).sort(((t,e)=>t.overflows[1]-e.overflows[1]))[0])==null?void 0:V.placement;if(!o)switch(v){case"bestFit":{var W;const e=(W=S.filter((e=>{if(L){const n=t(e.placement);return n===T||n==="y"}return true})).map((t=>[t.placement,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])==null?void 0:W[0];e&&(o=e);break}case"initialPlacement":o=f;break}if(r!==o)return{reset:{placement:o}}}return{}}}};function T(t,e){return{top:t.top-e.height,right:t.right-e.width,bottom:t.bottom-e.height,left:t.left-e.width}}function E(t){return h.some((e=>t[e]>=0))}const O=function(t){t===void 0&&(t={});return{name:"hide",options:t,async fn(e){const{rects:n}=e;const{strategy:o="referenceHidden",...s}=i(t,e);switch(o){case"referenceHidden":{const t=await b(e,{...s,elementContext:"reference"});const o=T(t,n.reference);return{data:{referenceHiddenOffsets:o,referenceHidden:E(o)}}}case"escaped":{const t=await b(e,{...s,altBoundary:true});const o=T(t,n.floating);return{data:{escapedOffsets:o,escaped:E(o)}}}default:return{}}}}};function k(t){const e=l(...t.map((t=>t.left)));const n=l(...t.map((t=>t.top)));const o=y(...t.map((t=>t.right)));const s=y(...t.map((t=>t.bottom)));return{x:e,y:n,width:o-e,height:s-n}}function L(t){const e=t.slice().sort(((t,e)=>t.y-e.y));const n=[];let o=null;for(let t=0;t<e.length;t++){const s=e[t];!o||s.y-o.y>o.height/2?n.push([s]):n[n.length-1].push(s);o=s}return n.map((t=>r(k(t))))}const C=function(e){e===void 0&&(e={});return{name:"inline",options:e,async fn(n){const{placement:s,elements:a,rects:f,platform:m,strategy:u}=n;const{padding:d=2,x:g,y:p}=i(e,n);const h=Array.from(await(m.getClientRects==null?void 0:m.getClientRects(a.reference))||[]);const w=L(h);const x=r(k(h));const v=c(d);function b(){if(w.length===2&&w[0].left>w[1].right&&g!=null&&p!=null)return w.find((t=>g>t.left-v.left&&g<t.right+v.right&&p>t.top-v.top&&p<t.bottom+v.bottom))||x;if(w.length>=2){if(t(s)==="y"){const t=w[0];const e=w[w.length-1];const n=o(s)==="top";const i=t.top;const c=e.bottom;const r=n?t.left:e.left;const l=n?t.right:e.right;const a=l-r;const f=c-i;return{top:i,bottom:c,left:r,right:l,width:a,height:f,x:r,y:i}}const e=o(s)==="left";const n=y(...w.map((t=>t.right)));const i=l(...w.map((t=>t.left)));const c=w.filter((t=>e?t.left===i:t.right===n));const r=c[0].top;const a=c[c.length-1].bottom;const f=i;const m=n;const u=m-f;const d=a-r;return{top:r,bottom:a,left:f,right:m,width:u,height:d,x:f,y:r}}return x}const A=await m.getElementRects({reference:{getBoundingClientRect:b},floating:a.floating,strategy:u});return f.reference.x!==A.reference.x||f.reference.y!==A.reference.y||f.reference.width!==A.reference.width||f.reference.height!==A.reference.height?{reset:{rects:A}}:{}}}};async function B(e,n){const{placement:c,platform:r,elements:l}=e;const a=await(r.isRTL==null?void 0:r.isRTL(l.floating));const f=o(c);const m=s(c);const u=t(c)==="y";const d=["left","top"].includes(f)?-1:1;const g=a&&u?-1:1;const p=i(n,e);let{mainAxis:h,crossAxis:y,alignmentAxis:w}=typeof p==="number"?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:p.mainAxis||0,crossAxis:p.crossAxis||0,alignmentAxis:p.alignmentAxis};m&&typeof w==="number"&&(y=m==="end"?w*-1:w);return u?{x:y*g,y:h*d}:{x:h*d,y:y*g}}const H=function(t){t===void 0&&(t=0);return{name:"offset",options:t,async fn(e){var n,o;const{x:s,y:i,placement:c,middlewareData:r}=e;const l=await B(e,t);return c===((n=r.offset)==null?void 0:n.placement)&&(o=r.arrow)!=null&&o.alignmentOffset?{}:{x:s+l.x,y:i+l.y,data:{...l,placement:c}}}}};const S=function(e){e===void 0&&(e={});return{name:"shift",options:e,async fn(n){const{x:s,y:c,placement:r}=n;const{mainAxis:l=true,crossAxis:f=false,limiter:m={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...u}=i(e,n);const d={x:s,y:c};const g=await b(n,u);const p=t(o(r));const h=w(p);let y=d[h];let x=d[p];if(l){const t=h==="y"?"top":"left";const e=h==="y"?"bottom":"right";const n=y+g[t];const o=y-g[e];y=a(n,y,o)}if(f){const t=p==="y"?"top":"left";const e=p==="y"?"bottom":"right";const n=x+g[t];const o=x-g[e];x=a(n,x,o)}const v=m.fn({...n,[h]:y,[p]:x});return{...v,data:{x:v.x-s,y:v.y-c,enabled:{[h]:l,[p]:f}}}}}};const F=function(e){e===void 0&&(e={});return{options:e,fn(n){const{x:s,y:c,placement:r,rects:l,middlewareData:a}=n;const{offset:f=0,mainAxis:m=true,crossAxis:u=true}=i(e,n);const d={x:s,y:c};const g=t(r);const p=w(g);let h=d[p];let y=d[g];const x=i(f,n);const v=typeof x==="number"?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const t=p==="y"?"height":"width";const e=l.reference[p]-l.floating[t]+v.mainAxis;const n=l.reference[p]+l.reference[t]-v.mainAxis;h<e?h=e:h>n&&(h=n)}if(u){var b,A;const t=p==="y"?"width":"height";const e=["top","left"].includes(o(r));const n=l.reference[g]-l.floating[t]+(e&&((b=a.offset)==null?void 0:b[g])||0)+(e?0:v.crossAxis);const s=l.reference[g]+l.reference[t]+(e?0:((A=a.offset)==null?void 0:A[g])||0)-(e?v.crossAxis:0);y<n?y=n:y>s&&(y=s)}return{[p]:h,[g]:y}}}};const V=function(e){e===void 0&&(e={});return{name:"size",options:e,async fn(n){var c,r;const{placement:a,rects:f,platform:m,elements:u}=n;const{apply:d=()=>{},...g}=i(e,n);const p=await b(n,g);const h=o(a);const w=s(a);const x=t(a)==="y";const{width:v,height:A}=f.floating;let R;let D;if(h==="top"||h==="bottom"){R=h;D=w===(await(m.isRTL==null?void 0:m.isRTL(u.floating))?"start":"end")?"left":"right"}else{D=h;R=w==="end"?"top":"bottom"}const P=A-p.top-p.bottom;const T=v-p.left-p.right;const E=l(A-p[R],P);const O=l(v-p[D],T);const k=!n.middlewareData.shift;let L=E;let C=O;(c=n.middlewareData.shift)!=null&&c.enabled.x&&(C=T);(r=n.middlewareData.shift)!=null&&r.enabled.y&&(L=P);if(k&&!w){const t=y(p.left,0);const e=y(p.right,0);const n=y(p.top,0);const o=y(p.bottom,0);x?C=v-2*(t!==0||e!==0?t+e:y(p.left,p.right)):L=A-2*(n!==0||o!==0?n+o:y(p.top,p.bottom))}await d({...n,availableWidth:C,availableHeight:L});const B=await m.getDimensions(u.floating);return v!==B.width||A!==B.height?{reset:{rects:true}}:{}}}};export{A as arrow,D as autoPlacement,v as computePosition,b as detectOverflow,P as flip,O as hide,C as inline,F as limitShift,H as offset,S as shift,V as size};

